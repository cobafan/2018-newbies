#!/usr/bin/env ruby

require 'pathname'

require "pathname"
ENV["BUNDLE_GEMFILE"] ||= File.expand_path("../../Gemfile",
  Pathname.new(__FILE__).realpath)

bundle_binstub = File.expand_path("../bundle", __FILE__)

if File.file?(bundle_binstub)
  if File.read(bundle_binstub, 150) =~ /This file was generated by Bundler/
    load(bundle_binstub)
  else
    abort("Your `bin/bundle` was not generated by Bundler, so this binstub cannot run.
Replace `bin/bundle` by running `bundle binstubs bundler --force`, then run this command again.")
  end
end

require "rubygems"
require "bundler/setup"
require "dotenv/load"

require 'fileutils'
require 'open3'
require 'optparse'
require 'aws-sdk-s3'
require 'aws-sdk-codedeploy'

# path to your application root.
APP_ROOT = Pathname.new File.expand_path('../../', __FILE__)
ARCHIVE_ROOT = APP_ROOT.join('tmp', 'deployment')

options = {
  team: ENV.fetch('TEAM') { '' },
  revision: 'HEAD',
}
opt = OptionParser.new.tap do |opt|
  opt.on('-t', '--team=TEAM') { |v| options[:team] = v }
  opt.on('-r', '--revision=REVISION') { |v| options[:revision] = v }
end
opt.parse!(ARGV)

REVISION = `git rev-parse #{options[:revision]}`.strip
ARCHIVE = "#{ARCHIVE_ROOT.join(REVISION)}.tar"

if options[:team].empty?
  puts "TEAM is required."
  exit 1
end

def sh(*cmd, &block)
  Open3.popen3(*cmd, &block)
end

puts "Create archive ..."
FileUtils.mkdir_p(ARCHIVE_ROOT)
sh("git archive --format=tar -o #{ARCHIVE} #{REVISION}", chdir: APP_ROOT.to_s) do |stdin, stdout, stderr, wait_thr|
  stdout.each { |line| STDOUT.puts line }
  stderr.each { |line| STDERR.puts line }

  wait_thr.join
end

puts "Embedding REVISION ..."
open(APP_ROOT.join('REVISION'), 'w') { |f| f.puts(REVISION) }

sh("tar -rf #{ARCHIVE} REVISION", chdir: APP_ROOT.to_s) do |stdin, stdout, stderr, wait_thr|
  stdout.each { |line| STDOUT.puts line }
  stderr.each { |line| STDERR.puts line }

  wait_thr.join
end

puts "Embedding .env ..."
if File.exists?(APP_ROOT.join('.env.production'))
  sh("tar -rf #{ARCHIVE} .env.production", chdir: APP_ROOT.to_s) do |stdin, stdout, stderr, wait_thr|
    stdout.each { |line| STDOUT.puts line }
    stderr.each { |line| STDERR.puts line }

    wait_thr.join
  end
end

FileUtils.rm(APP_ROOT.join('REVISION'))

s3 = Aws::S3::Client.new(region: 'ap-northeast-1')

archive = open(ARCHIVE, 'rb')

puts "Upload archive ..."
s3resp = s3.put_object(
  bucket: 'mf2018-app',
  key: "deployment/#{options[:team]}/#{REVISION}.tar",
  body: archive
)
archive.close

puts "Create deployment ..."
codedeploy = Aws::CodeDeploy::Client.new(region: 'ap-northeast-1')
resp = codedeploy.create_deployment(
  application_name: "nova-#{options[:team]}",
  deployment_group_name: "nova-#{options[:team]}",
  revision: {
    revision_type: "S3",
    s3_location: {
      bucket: "mf2018-app",
      key: "deployment/#{options[:team]}/#{REVISION}.tar",
      bundle_type: "tar", # accepts tar, tgz, zip, YAML, JSON
      e_tag: s3resp.etag,
    },
  },
  update_outdated_instances_only: false,
  ignore_application_stop_failures: true,
  file_exists_behavior: 'OVERWRITE'
)
